## 3.3 死锁

- 资源：在任何时刻只能被单个进程使用的任何对象。
  - 具有排他性
  - 一个类型的资源可以有若干实例
- 资源的分类
  - 可抢占资源：从拥有它的进程处抢占而没有副作用，如存储器
  - 不可抢占资源

- 死锁：死锁是指系统中多个进程无限制地等待永远不会发生的条件

#### 死锁原理

- 死锁的规范定义：如果一个进程集合中的每一个进程都在等待只能由本集合中的其他进程才能引发的事件，那么该进程是死锁的

- 死锁的必要条件

  - 互斥：任一时刻只允许一个进程使用资源
  - 请求和保持：进程在请求其余资源时，不主动释放已经占用的资源
  - 非剥夺：进程已经占用的资源，不会被强制剥夺
  - 环路等待：环路中的每一条边是进程在请求另一进程已经占有的资源。系统中必然有一条有两个或两个以上的进程组成的环路

  破坏上述条件之一，即可打破死锁

- 死锁模型——有向图

  - 方形表示资源，圆形表示进程
  - 资源节点指向进程节点表示资源已被占用；进程指向资源表示该进程正在请求该资源，并处于阻塞等待的状态。

  <img src="死锁模型.png" width=60%>

- 处理死锁的策略

  1. 忽略该问题

  2. 检测死锁并修复

  3. 谨慎地对资源进行动态分配，动态避免死锁

  4. 通过破坏上述四个必要条件之一，来防止死锁发生

     

- 处理死锁的有效方法的对比
| 方法 |                      资源分配策略                       |                         各种可能模式                         |                           主要优点                           |                           主要缺点                           |
| :--: | :-----------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: | :----------------------------------------------------------: |
| 预防 |                  保守的；宁可资源闲置                   | 一次请求所有资源<条件2><br/>资源剥夺<条件3><br/>资源按序申请<条件4> | 适用于作突发式处理的进程；不必剥夺<br/>适用于状态可以保存和恢复的资源<br/>可以在编译时（而不必在运行时）就进行检查 | 效率低；进程初始化时间延长<br/>剥夺次数过多；多次对资源重新起动<br/>不便灵活申请新资源 |
| 避免 | 是“预防”和“检测”的折衷<br/>（在运行时判断是否可能死锁） |                   寻找可能的安全的运行顺序                   |                         不必进行剥夺                         |    使用条件：必须知道将来的资源需求；进程可能会长时间阻塞    |
| 检测 |              宽松的；只要允许，就分配资源               |                   定期检查死锁是否已经发生                   |         不延长进程初始化时间；允许对死锁进行现场处理         |                  通过剥夺解除死锁，造成损失                  |



#### 死锁的处理

- 鸵鸟算法：对死锁视而不见

##### 死锁的检测和恢复

- 保存资源的请求和分配信息，利用某种算法对这些信息加以检查，以判断是否存在死锁。死锁检测算法主要是检查是否有循环等待。
- 死锁的恢复
  - 通过撤消代价最小的进程，以解除死锁
  - 挂起某些死锁进程，并抢占它的资源，以解除死锁
- 撤消进程的原则
  - 进程优先级
  - 系统会计过程给出的运行代价

#### 死锁的预防

- 对进程施加适当的限制以从根本上消除死锁

- 使死锁发生的四个必要条件至少有一个不成立，则死锁将不会发生

  |    条件    |          方法          |
  | :--------: | :--------------------: |
  |    互斥    | 对所有资源进行spooling |
  | 保持并等待 |   初始时申请所有资源   |
  |  不可剥夺  |       将资源剥夺       |
  |  循环等待  |     对资源进行编号     |

##### 全局编号

- 所有资源赋予一个全局编号，进程申请资源必须按照编号顺序
- 改进：不允许进程申请编号比当前所占有资源编号低的资源

#### 避免死锁

