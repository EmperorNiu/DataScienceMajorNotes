修改日期：2019年4月20日

## 进程间通讯

#### 竞争条件 race conditions

- 两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序，此种现象称为竞争条件。

- 存在竞争条件的程序是不合格的，虽然大多数情况此程序会准确执行。

- 例子：假脱机打印程序

  - 当进程A刚刚读取完打印空闲槽的位置就被进程B打印，进程B读取相同的打印空闲槽的位置，此时CPU回到进程A，进程A又把任务放到刚才读的打印空闲槽位置，那么进程B的打印任务永远不会被执行

#### 临界区
- 对共享内存进行访问的**程序片段**称为临界区。比如对共享变量的修改。定义临界区是为了避免竞争条件。
- 避免竞争条件的解决方案具备的条件
	1. 任何两个进程不能同时处于临界区
	2. 不应对CPU的速度和数目进行任何假设
	3. 临界区外的进程不得阻塞其他进程
	4. 不得使进程在临界区外无休止的等待

### 阻塞进程的方法

一个好的多进程程序要满足：逻辑正确，并行度高。

#### 忙等待: 自旋锁

- 思想：当一个进程想进入临界区时，先检查是否允许进入，若不允许，进程将进入忙等待，直到许可为止。

- 使用条件：用于等待时间很短的情况。
- 优点：避免进程切换的时间
- 缺点：浪费CPU资源，可能有优先级反转问题

##### Peterson互斥解法： 纯软件解法

```c
#define FALSE 0
#define TRUE 1
#define N 2						//进程数

int turn;						//轮到谁
int interested[N];				//是否要进入临界区

void enter_region(int process)	//传入进程号0or1
{
    int other;					//另一个进程
    other = 1 - process;
    interested[process] = TRUE;
    turn  = process;
    while(turn == process && interested[other] == TRUE)
}
void leave_ region(int process)
{
    interested[process] = FALSE;
}
```



##### TSL 解法：软硬件结合的方法，现实中使用的方法

```
TSL RX，LOCK
```

通过硬件支持，使读数和写数操作是不可分割的，即该指令结束前其他处理机制不允许访问该储存器字，可理解为测试并上锁。执行TSL指令的CPU将锁住内存总线已禁止其他CPU在本指令结束之前访问内存。

汇编实现：

```assembly
enter_region:
	TSL register,lock
	cmp register,#0
	jne enter_region
	ret
	
leave_region:
	move lock,#0
	ret
```

##### 优先级翻转问题

考虑两个进程，H进程优先级高，L优先级低。调度规则规定只要高优先级进程处于就绪状态，他就可以运行，所以当L处于临界区，H处于就绪态时，H开始忙等待，但由于H优先级高又处于就绪态，L就不会被调度。所以L无法离开临界区。所以H永远忙等待下去。

#### 睡眠等待

- 适用：等待时间很长或者等待时间不确定。减少资源浪费

sleep系统调用将引起调用进程阻塞

##### 生产者-消费者问题

问题：

​	两个进程共享一个公共的固定大小的缓冲区。其中一个是生产者，负责将信息放入缓冲区，另一个是消费者，负责将从缓冲区取出信息。

- 唤醒等待位。当向一个清醒的进程发送一个唤醒信号时，唤醒信号丢失。导致进程永远睡眠，由于对count的访问未加限制，会导致生产者填满整个缓冲区，最终进程将永远睡眠。

#### 原语

- 原语(primitive)：由若干条指令构成的“原子操作(atomic operation)”过程，作为一个整体而不可分割，即要么全都完成，要么全都不做。许多系统调用就是原语。

#### 信号量

- 原语： 由若干指令构成的原子操作过程，作为一个整体而不可分割。
- 信号量：使用一个整型变量累计唤醒次数。
  - 当它为0时，表示没有累计下来的唤醒操作；
  - 当它为正值时，表示有一个或多个被累积下来的唤醒操作

##### down操作（不可分割的原子操作）：是一个原语

- 检查信号量的值

  - 如果大于0，将其值-1并继续

  - 如果等于0，则进程将睡眠，而且此时down操作并未结束


##### up操作

如果一个或多个进程在该信号量上睡眠，无法完成一个先前down操作，则由系统选择其中一个，并允许其完成它的down操作

##### 用信号量解决生产者-消费者问题--信号量丢失问题

down和up操作包括检测信号量、修改信号量以及在需要的时候使进程睡眠。TSL指令保证上述三个操作，同一时刻只有一个CPU对信号量进行操作。
在生产者-消费之问题中，使用三个信号量：

- full：慢的缓冲槽数目 初始化为0
- empty：记录空的缓冲槽总数 初始化为N
- mutex：确保生产者和消费者不会同时访问缓冲区 初始化为1

##### 信号量的缺点

​	信号量同步操作分散，易读性差、不利于修改和维护、正确性难以保证

### 管程

##### 管程的实现要素

- 基本思想是把信号量及其操作原语封装在一个对象内部。即：将共享变量以及对共享变量能够进行的所有操作集中在一个模块中。
- 是过程、变量和相关数据结构的集合，构成一个特殊的模块或软件包。引入管程可提高代码的可读性，便于修改和维护，正确性易于保证。
- 管程中的共享变量在管程外部是不可见的，外部只能通过调用管程中所说明的过程（函数）来间接地访问管程中的共享变量
- 为了保证管程共享变量的数据完整性，规定管程互斥进入
- 管程通常是用来管理资源的，因而在管程中应当设有进程等待队列以及相应的等待及唤醒操作

##### 条件变量

- 由于管程通常是用于管理资源的，因而在管程内部，应当存在某种等待机制；当进入管程的进程因资源被占用等原因不能继续运行时使其等待

### 信息传递

- send(destination,&message,&staus)
- receive(source,&message,&status)

为了防止消息丢失，发送方和接收方可以达成如下一致：一旦信息被接收到，接收方马上回送一条特殊的应答(acknowledgement)消息。如果发送方在一段时间间隔内未收到应答，则进行重发

区分新消息和一条重发的老消息是非常重要的。通常采用在每条原始消息中嵌入一个连续的序号来解决该问题