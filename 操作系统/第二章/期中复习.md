# 期中复习

## 操作系统名词解释

- 进程：进程是对正在运行程序的一个抽象，包括程序计数器、寄存器和变量的当前值。

- 上下文切换：保存当前状态，载入新进程的之前保存的状态

- 守护进程： 处于后台，在收到请求消息到来时才会醒来处理请求的进程

- 再生服务器：启动或重启驱动和服务器；它初始处于阻塞态，等待消息告诉它创建什么。

- 进程控制块（PCB）：由OS维护的用来记录进程相关信息的一块内存

- 竞争条件:两个或多个进程读写某些共享数据，而最后的结果取决于进程运行的精确时序，此种现象称为竞争条件。

- 临界区：对共享内存进行访问的程序片段称作临界区

- 原语(primitive)：由若干条指令构成的“原子操作(atomic operation)”过程，作为一个整体而不可分割，即要么全都完成，要么全都不做。许多系统调用就是原语。

- 多道程序设计：

  多道程序设计技术是在计算机内存中同时存放几道相互独立的程序，使它们在调度程序控制下，相互穿插执行。它将内存划分为几个区，每个分区存放不同的作业。当一个作业正在等待I/O操作完成时，另一个作业就可以使用CPU。大部分时间CPU的使用率接近100%

- 调度机制与调度策略

  - 调度机制：将调度算法以某种形式参数化
  - 调度策略：由用户进程填写参数后，相应的策略
  
- 中断向量：位于靠近内存底部的位置，包含中断服务器的入口地址

## 操作系统简答题

- 进程的状态？
  1. 运行态：实际占用处理机
  2. 就绪态：可运行，因为其它进程正在运行而暂时被挂起
  3. 阻塞态：除非外部事件发生否则不能运行

- 进程与线程的关系？

  - 观察进程的一种方式是把进程是为一组相关资源的集合（地址空间），包括打开的文件、子进程……通过进程的形式把它们放到一起方便管理

  - 进程具有的另一个概念是它是一个执行流，通常成为线程。线程具有程序计数器，寄存器，堆栈。

  - 线程的优点

    ​	减小并发执行的时间和空间开销（线程的创建、退出和调度），因此容许在系统中建立更多的线程来提高并发程度。

  - **所以进程用来集合资源，线程是CPU中调度的实体**

    |     每个进程项     | 每个线程项 |
    | :----------------: | :--------: |
    |      地址空间      | 程序计数器 |
    |      全局变量      |   寄存器   |
    |      打开文件      |    堆栈    |
    |       子进程       |    状态    |
    |       定时器       |            |
    | 信号和信号处理程序 |            |
    |      统计信息      |            |

- 微内核有什么好处？

  微内核结构（很小的内核，将宏内核中的内容尽量的放到用户空间），是一组进程的集合，更多功能由用户进程实现结合，内核功能较少，进程间通信通过IPC机制（消息传递）进行通信（内核实现的）。微内核更安全稳定，更灵活，更模块化(如更换一个文件系统不需要重新编译内核），但性能有所损耗（由于大量进程通信）。

- 中断处理步骤

  1. 硬件压栈程序计数器等
  2. 硬件按中断向量下载新的程序计数器
  3. 汇编语言程序存储寄存器值(至当前进程的PCB)
  4. 汇编语言程序设置新的栈(为运行处理程序作准备)
  5. C语言中断服务程序运行
  6. 对等待的就绪任务作标识(发生中断后相关进程状态发生变化)
7. 调度程序决定哪个进程是下一个将运行的
8. C语言中断服务程序返回汇编代码
9. 汇编语言程序开始运行新的当前进程(载入寄存器值和内存映射)

- 两种线程对比

  |                          用户级线程                          |                          内核级线程                          |
  | :----------------------------------------------------------: | :----------------------------------------------------------: |
  |                            切换快                            |                         切换相对较慢                         |
  |                   一个线程阻塞整个进程阻塞                   |                 一个线程阻塞整个进程不会阻塞                 |
  |                特定的应用可以应用定制的调度器                |           内核考虑调度时会将线程切换的代价考虑进去           |
  |                  操作系统感知不到线程的存在                  |                  操作系统感知的到线程的存在                  |
| 用户线程的维护由应用进程完成,用户线程切换不需要内核特权.时间片分配给进程，多线程则每个线程就慢… | 内核维护进程和线程的上下文信息；线程切换由内核完成；时间片分配给线程，所以多线程的进程获得更多CPU时间。 |

## 伪代码题目

- 生产者消费者问题

  ```c
  int full = 0;
  int empty = N;
  int mutex = 1;
  
  void producer
  {
  	int item;
      while(TRUE)
      {
          item = produce_item();
          down(&empty);
          down(&mutex);
          insert_item(item);
          up(&mutex);
          up(&full);
      }
  }
  
  void  consummer
  {
      int item;
      while(TRUE)
      {
          down(&full);
          down(&mutex);
          item = remove_item();
          up(&mutex);
          up(&empty);
          consume_item(item);
      }
  }
  ```

  

- 哲学家进餐问题

  ```c
  #define LEFT (i+N-1)%N
  #define RIGHT (i+1)%N
  #define THINKINg 0
  #define HUNGRY 1
  #define EATING 2
  int mutex=1;
  int state[N];
  int s[N];
  
  void philosopher(int i)
  {
      while(TRUE)
      {
          thinking();
          take_forks(i);
          eat();
          put_forks(i);
      }
  }
  
  void take_forks(int i)
  {
      down(&mutex);
      state[i]=HUNGRY;
      test(i);
      up(&mutex);
      down(s[i])
  }
  
  void put_forks(int i)
  {
      down(&mutex);
      state[i] = THINKING;
      test(LEFT);
      test(RIGHT);
      up(&mutex);
  }
  
  void test(int i)
  {
      if(state[i]==HUNGRY && state[LEFT]!=EATING && state[RIGHT]!=EATING)
      {
          state[i]=EATING;
          up(&s[i]);
      }
  }
  ```

- 读者写者问题

```
int mutex = 1;
int db = 1;
int rc=0;

void reader()
{
	while(TRUE)
	{
         down(&mutex);
        rc += 1;
        if(rc==1)
            down(&db);
        up(&mutex);
        read_data_base();
        down(&mutex);
        rc -= 1;
        if(rc==0)
            up(&db);
        up(&mutex);
        use_data();
	}
}

void writer()
{
	while(TRUE)
	{
        think_up_data();
        down(&db);
        write(data);
        up(&db);
	}  
}
```



## 计算题--基于进程调度

- 平均响应时间：

  用户输入一个请求（如击键）到系统给出首次响应（如屏幕显示）的时间

- 平均周转时间：

  每个作业从提交到完成（得到结果）所经历的时间的平均值。注意不是总时间的平均值

- CPU利用率
- 可调度的实时系统

$$
\sum^{m}_{i=1}\frac{C_i}{P_i}\le1\\隐含条件：上下文切换开销很小
$$


​				

